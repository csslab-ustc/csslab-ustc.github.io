# **区块链：去中心化、集体维护、不可篡改**

（2021.4.8讨论班所讲内容，参考郭燕老师知乎专栏+《图说区块链》							by林昕蓉）

#### **·区块链的模型架构**

#### **·链式结构**

#### **·比特币中的密码学：1.哈希函数		2.非对称加密**

#### **·共识机制：工作量证明PoW(proof of work)决定由谁创建新区块**

#### **·激励机制：激励参与节点维持整个系统正常工作**

#### **·Merkle Tree：验证某一交易是否存在**

区块链本质上是一个去中心化的分布式账本，其本身是一系列基于密码学的互相关联的数据块，每个数据块中包含了许多条经网络中各个节点确认的交易信息。

**在区块链中每个节点都可以显示总账、维护总账，并且不能修改账本，除非控制了超过51%的节点（这几乎是不可能的）**



## **区块链的模型架构**



​        ![img](./picture/notepic1.png)        

# **链式结构**

首先建立“创世区块”，之后再同样的规则下创建规格相同的区块，通过链式结构依次相连组成一条主链条。

​        ![img](./picture/notepic2.png)        

​        ![img](./picture/notepic3.png)        

**区块高度：**区块序号

**父区块：**前一个区块的哈希

**Nonce：**挖矿时需要找到的随机数值，用于工作量证明

**目标哈希：**target，用于工作量证明

**Merkle root:**能够总结并快速归纳校验区块中所有交易数据

**交易**：记录发生的转账（如：A发送 1 个比特币给B）

# **比特币中的密码学**

# **1.哈希函数**

**哈希算法是区块链中保证交易信息不被篡改的单向密码机制，哈希算法接收一段明文后，以一种不可逆的方式将其转化为一段长度较短、位数固定的散列数据**

理想的加密哈希函数有五个主要属性：

1.**确定性：**相同的消息x总是产生相同的散列H(x)

\2. 快速计算

\3. **hiding：**知道哈希的结果不能倒推输入，不可逆

\4. **雪崩效应：**对输入信息x进行小的更改便会引起哈希值H(x)的巨大改变

\5. **抗冲突：**找到具有相同散列值的两个不同消息是不可行的

（很难找到x≠y，使得H(x)=H(y)）



区块链中的区块主要依赖于两种基于Hash的数据结构：

1. 区块的**哈希链**：通过哈希指针链接各个区块
2. 区块内每个的交易组成的树状结构**Merkle Tree**：用于验证交易是否存在



# **2.非对称加密**

在区块链中，

公钥（相当于银行账户）用于识别身份

私钥（相当于账户密码）控制账户内持有的币，控制智能合约所需的认证程序

公钥由私钥生成（椭圆曲线RSA），数字签名也由私钥生成



在区块链中，使用公钥和私钥来表示身份，假设区块链中有两个人，分别是A和B，A想向B证明自己是真的A，则A只需用私钥对文件进行签名并发送给B，B使用A的公钥对文件进行签名验证，若验证成功，则证明这个文件是A用A的私钥加密过的，A的私钥只有A才能持有，可验证A确实是A



信息发送者A：用A的私钥对信息进行签名，使用信息接收方B的公钥对信息加密

信息接受方B：用信息发送者A的公钥验证发送方身份，用B的私钥解密信息



花费比特币的方式就是使用私钥对自己的未花费交易进行签名

​        ![img](./picture/notepic4.png)                ![img](./picture/notepic5.png)        





------





**区块链的工作过程**

比特币的共识算法过程如下：

1. 新的交易被广播到全网所有的节点。
2. 每个节点将收到的新交易打包进区块。
3. 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明PoW
4. 每一轮中最先完成PoW哈希计算的节点将该区块链接到链上，并广播该区块。
5. 如果其他节点检验哈希值，发现区块中所有的交易都是有效的（比特币没有双花，签名验证正确等），则其他节点接受这个区块；
6. 节点转而去计算新的区块，接受前一个区块的方式是将新创建的区块跟随在前区块的末尾（即：在之后新创建的区块中包括这个块的哈希）。



## **谁来创建区块？**

1. 去中心化，创造新区块的节点是随机的		--任何完成了工作量证明的节点
2. 给创造区块的节点提供奖励				--挖矿奖励
3. 创建区块的过程不是简单的				--工作量证明，需要算力

## **共识机制：工作量证明PoW(proof of work)决定由谁创建新区块**

比特币的工作证明就是hash puzzles。为了创建一个区块，节点需要能够找到一个数值nonce，使得当计算哈希时，前一个hash，包含在区块中的交易，以及nonce这三者连接之后，它的哈希值小于某个target。

用公式写出来，长这样：

​        ![img](./picture/notepic6.png)        

**找到这个Nonce的唯一方法就是尝试各种值，直到运气好找到一个。**

工作证明的存在基本上实现了对随机性的要求，没有人能确定哪个节点可以产生下一个区块

比特币中的hash计算有三个特点

1. 很难计算。产生一个区块需要的计算大概是10^20次哈希，普通的笔记本电脑根本没有竞争力。因此，参与计算的行为被称作**mining，挖矿**。
2. 难度可调节。通过调整target，控制区块的产生速度。
3. 验证非常容易。

（除此之外还有POS（权益证明，proof of stake）,DPOS(股份授权证明)）

​        ![img](https://docimg2.docs.qq.com/image/SDwVmMhx30G69fZOYX4_4A?w=787&h=102)        

## **激励机制：激励参与节点维持整个系统正常工作**

在比特币网络中，共有两个激励方式：

一种是挖出新区块的奖励（Block reward）

一种是打包交易的费用（transaction fees）

## **Merkle Tree：帮助节点验证某一交易是否存在**

​        ![img](./picture/notepic7.png)        

在上图中， TA ~ TH 是区块中包括的正常的交易。从底层向上构建Merkle树，对每个交易都进行哈希，分别得到 HA ~ HH 。生成的单个哈希与邻近的哈希值组合，再次进行哈希。譬如 HA 和 HB 组合，再次进行哈希，得到 HAB 。这个过程一直持续下去，从底层一直到树根。可以看出，Merkle树的特点是：

--Merkle Tree的叶子节点是数据块的哈希。

--Merkle Tree的非叶子节点的哈希值根据它下面所有叶子节点的值哈希计算得到。

## **Merkle tree的作用**

默认情况下，一旦接受到一个新交易，节点需要验证它，特别是，验证交易的输入中的每一个之前是否被花费。

需要从可信节点获得区块链的完整的头部信息，以及和他想验证的交易的Merkle分支

使用Merkle树之后，可以很容易验证区块中的交易有没有被篡改。

​        ![img](./picture/notepic8.png)        

如上图，如果需要证明某个区块上是否存在一笔交易Tx3，那么全节点返回的Merkle路径是Hash2和Hash01。只需要这两个值就可以进行验证过程如下：

- Step1：计算交易Tx3的哈希值，得到Hash3
- Step2：通过Hash2和Hash3的哈希值，得到父节点的哈希值Hash23
- Step3：同上，通过计算Hash23和Hash01哈希值，得到根节点的哈希值。
- Step4：将上一步得到的根哈希值对比区块头中MerkleTree的根哈希值，如果相同，则证明该区块中存在交易Tx3，否则说明不存在。



------





# **总结：去中心化、集体维护、不可篡改**

## **为什么要去中心化？**

**中心化的不可靠**

**防止中心节点毁坏导致交易失败**



​        ![img](./picture/notepic9.png)        

​        ![img](./picture/notepic10.png)        

## **如何实现去中心化？**

用什么实现？		--互联网，互联网内各个节点地位平等

互联网的作用？	--传递消息

怎么用传递消息的方式实现货币交易？		--消息即交易

货币就是一个个交易记录，这些记录被所有节点记录并认可



## **去中心化需要解决什么问题？**

1. 谁维护交易账本？			--每个节点都维护一个账本，所有交易都记录在账本上	
2. 谁来验证交易是否是有效？	--矿工节点（验证是否有足够多的钱用于支付）	
3. 谁创建新的比特币？		--矿工节点（挖出新区块）



## **怎样实现集体维护？**

1. 所有节点维护交易账本、决定交易是否是有效，每个节点都要为所有人记账
2. 节点为什么要为所有人记账？（**激励机制**）

--使维持整个系统正常工作才符合大多数人的利益，参与者有强烈的意愿能获得比特币这个奖励（挖矿奖励、交易费用）

1. 各个节点之间如何同步账本信息？（**共识机制：工作量证明**）

--只认可那些已经完成工作量证明、被打包到区块的交易



## **怎样保证之前达成共识的内容不可篡改？**

**哈希**：后一个区块存储了前一个区块的哈希值，篡改链中间某一区块的内容会导致瀑布效应。由于区块头里面包含“父区块哈希值”字段，所以当前区块的哈希值也受到该字段的影响。如果父区块的身份标识发生变化，子区块的身份标识也会跟着变化，以此类推。一旦一个区块有很多代以后，这种**瀑布效应**将保证该区块不会被改变，除非强制重新计算该区块所有后续的区块。

## 

# **END**



























































补充：



每个交易有多个输入，多个输出

​        ![img](./picture/notepic11.png)        





货币网络中可能的攻击方法。

1. 偷比特币。Alice有没有可能去其他用户的比特币呢？譬如Alice创建了一个区块，区块中她试图伪造一个交易“Bob发送10个比特币给Alice。”如果要让这个交易合法，那么Alice必须能够伪造Bob的签名，但是Alice如果没有Bob的私钥，那么Alice就不能伪造签名。所以，只要底层的密码学基础没有被破坏，Alice就不可能偷Bob的币。
2. 拒绝服务。如果Alice非常讨厌Bob，她不愿意为Bob提供服务，譬如在自己创建的区块中，Alice就会故意忽略掉Bob相关的交易。这个攻击的问题是，Alice并不能控制区块的产生。即使Alice在一个区块中忽略了Bob的交易，其他诚实的节点会在交易中包括Bob的交易。
3. 双重支付。假设Alice从Bob购买了一个软件，然后她广播了一条交易“Alice付给Bob一些比特币”。诚实的节点看到了这条交易，并且将交易包含在区块中。当Bob看到这条交易被包括进去的时候，Bob认为Alice已经支付了，所以将软件发送给了Alice。然后Alice开始准备攻击，她自己或者她控制的节点开始准备下一个区块，在这个区块中包含的消息是把Alice刚才付给Bob的币付给自己或者她控制的账号“Alice付给Alice一些比特币”。如果Alice能够给成功地将第二条支付信息包含在区块链中，那么第一条消息，将会被忽视，就像从来没有出现过一样。

​        ![img](./picture/notepic12.png)        