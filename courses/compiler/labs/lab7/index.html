<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html">
    <title>Lab 7: Static Single-Assignment Form</title>
    <link rel="stylesheet" href="../labs.css" type="text/css">
</head>

<body>

<h1>Lab 7: Static Single-Assignment Form</h1>

<hr/>
<h2>Overview</h2>
<p>
    In this lab, you will add optimizations into your
    <code>Tiger</code> compiler, enabling it to generate
    better target code.
    Optimizations are program transformations to improve the code
    without changing its behavior.
    The improvement is highly dependent on the optimization
    goals, which might include but not limited to making the code
    faster, smaller, energy-efficient, and so on.
    For consistency, you will use static
    single-assignment forms (SSA) as the key intermediate
    representation to perform optimizations. SSA is a
    state-of-the-art IR also used in production compilers
    such as GCC or LLVM.
</p>
<p>
    This lab consists of four parts: first, in part A, you will
    warm yourself up by building some optimizations on AST.
    Second, in part B, you will
    build a static single-assigment form for your program by
    translating the control-flow graph.
    Third, in part C, you will implement classic data-flow analysis
    on SSA: liveness analysis, reaching definitions, available
    expressions, among others.
    Finally, in part D, you will implement local optimizations
    by leveraging analysis results:
    constant propagation, copy propagation, dead code elimination,
    and common sub-expression
    elimination, and so on.
</p>

<h3>Getting Started</h3>
<p>
    First check out the source we offered you for lab7:
</p>

<pre>
    $ <kbd>git commit -am 'my solution to lab6'</kbd>
    $ <kbd>git checkout -b lab7 origin/lab7</kbd>
</pre>
<p>
    these commands will first commit your changes to the lab6
    branch of your local Git repository, and then
    create a local lab7 branch and check out the remote lab7 branch
    into the new local lab7 branch.
</p>
<p>
    Again, you will need to merge your code from lab6 into the
    new lab7 branch:
<pre>
    $ <kbd>git merge lab6</kbd>
</pre>
<p>
    Do not forget to resolve any conflicts before commit to
    the local lab7 branch:
</p>
<pre>
    $ <kbd>git commit -am 'lab7 init'</kbd>
</pre>

<p>
    You should first import the new lab7 code into
    your favorite IDE, and make sure the code compiles. There
    are a bunch of new files that you
    should browse through:
</p>
<pre>
    cfg/*:       static single-assignment form and optimizations on it
</pre>

<h3>Hand-in Procedure</h3>
<p>
    When you finished your lab, zip you code and submit to the
    <a href="https://bb.ustc.edu.cn">online teaching system</a>.
</p>

<hr/>
<h2>Part A: Optimizing the AST</h2>
<p>
    Optimizations are highly dependent
    on the specific intermediate representation (IR) used: an
    optimization may be easy to perform
    on some IRs, but difficult if not impossible, on other IRs.
    In this part of the lab, you will first implement optimizations
    on the AST.
    Strictly speaking, AST is not a good IR
    for optimizations, due to its lacking of precise
    control/data flow information.
    However, some locals
    optimizations are still feasible on AST which might simplify
    AST considerably, benefiting
    later compiler phases.
</p>

<h3>Dead Class Elimination</h3>
<p>
    Any nontrivial Java project may contain many Java classes.
    However, not all classes are used in this project.
    So a <em>dead class elimination</em> optimization will
    remove the dead (i.e. unused) classes from the target
    program, reducing its sizes.
</p>
<p>
    You can use a <em><a
        href="https://en.wikipedia.org/wiki/Data-flow_analysis#The_work_list_approach">work-list</a></em>
    algorithm to perform dead
    classes elimination. First, push onto the work-list
    the <code>Main</code> class which contains the static Java
    <code>main</code> method, as this class will never be dead.
    Next, whenever a class <code>A</code> is popped from the
    work-list, push all classes used in <code>A</code> onto
    the work-list.
    Repeat this process until the work-list becomes empty.
</p>

<div class="required">
    <span class="header">Exercise 1.</span>
    Design and implement an algorithm to perform dead class
    elimination.
    Avoid pitfalls of removing live classes.
</div>

<p>
    Do not forget to do regression testing to guarantee your
    optimization works properly
</p>

<h3>Dead Code Elimination</h3>
<p>
    A dead code never executes. For example, the else branch
<pre class="code">
    if (true)
        System.out.println(1);
    else
        System.out.println(0);
</pre>
<p>
    is dead code.
    The goal for a <em>dead code elimination</em>
    is to remove code that can be statically determined to be dead.
</p>

<div class="required">
    <span class="header">Exercise 2.</span>
    Design an algorithm to perform dead class elimination.
    Implement it into your Tiger compiler.
</div>
<p>
    Again, do regression testing before continuing.
</p>

<h3>Algebraic Simplification</h3>
<p>
    An <em>algebraic simplification</em>
    simplifies program phrases, according to algebraic laws.
    For example, the expression <code>x*0</code> can be simplified to
    <code>0</code>.
</p>

<div class="required">
    <span class="header">Exercise 3.</span>
    Design and implement an algorithm to perform algebraic
    simplifications.
</div>
<p>
    Remember to do regression testing before continuing.
</p>

<h3>Constant Folding</h3>
<p>
    A <em><a href="https://en.wikipedia.org/wiki/Constant_folding">
    constant folding</a></em> computes the
    value of an expression statically at compile time.
    For example, the condition expression <code>0<2</code>
    can be evaluated to <code>true</code> statically.
</p>

<div class="required">
    <span class="header">Exercise 4.</span>
    Design an algorithm to perform constant folding.
</div>
<p>
    Compiler optimizations have cascaded effects, that is,
    one optimization might make other ones feasible.
    For example, after the constant folding
    optimization, the if condition may become a constant, so
    it is feasible to perform dead code elimination.
    As a result, optimizations should be conducted in a
    fixpoint style.
</p>

<div class="required">
    <span class="header">Exercise 5.</span>
    Implement a fixpoint algorithm for cascaded
    optimizations, to optimize an AST as much as possible.
    Think carefully of your design and write elegant code.
</div>


<hr/>
<h2>Part B: Static Single-Assigment Form (SSA)</h2>
<p>
    The <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">
    static single-assignment form</a>
    (SSA) is an important compiler intermediate representation,
    in which each variable is assigned (statically) just once.
    SSA is more advantageous over other compiler IRs in that
    its single-assignment property makes program analysis and optimization
    straightforward and simpler.
    As a result, SSA has become a de-factor IR in modern compilers
    for imperative, OO, or functional languages.
    In this part of the lab, you will build a static single-assigment
    form for your Tiger compiler, and conduct optimizations
    based on this IR.
</p>

<h3>SSA Data Structure</h3>
<p>
    You will implement data structures for SSA by extending
    the control-flow graph. Specifically, you will add a new
    syntactic form of statement: &phi;-function, which takes a list
    of values as arguments and produces a value, concurrently.
</p>
<div class="required">
    <span class="header">Exercise 6.</span>
    Read the code in <code>cfg/Cfg.java</code> to familiarize
    yourself with the data structures of SSA.
    It should be noted that all &phi;-instruction should be placed
    at the top of a block, which have not been enforced syntactically
    though.
</div>

<h3>Dominator Trees</h3>
<p>
    You will be constructing the SSA form for a program in the
    following steps: 1) calculate dominators;
    2) build dominator trees;
    3) calculate dominance frontiers;
    4) insert &phi;-functions; and
    5) rename variables.
    In this part, you will finish the first two steps.
</p>

<div class="required">
    <span class="header">Exercise 7.</span>
    Calculate, for each node <code>n</code> in the control-flow
    graph, the dominators for <code>n</code>.
    You can use the simple data-flow equation-based
    approach. You should topological-sort the flow graph first to
    speed up the calculation.
</div>

<div class="required">
    <span class="header">Exercise 8.</span>
    Calculate the dominator tree for the control-flow graph.
    Hint: you may first calculate the immediate dominator for each
    node.
</div>

<h3>Dominance Frontiers</h3>
<p>
    You may use the following algorithm to calculate dominance
    frontier (in which DF[n] and IDOM[n] represent the dominance
    frontier and immediate dominator, respectively):
</p>
<pre class="code">
    foreach(node n &in; CFG)
      DF[n] = &emptyset;  // initialized to empty
    foreach(node n &in; CFG)
      if(n has multiple predecessors)
        foreach(predecessor p of n)
          runner = p
          while(runner != IDOM[n])
            DF[runner] &cup;= {n}
            runner = IDOM[runner]
</pre>
<div class="required">
    <span class="header">Exercise 9.</span>
    Implement the algorithm calculating dominance frontiers
    as described above.
</div>

<h3>&phi;-function Insertion</h3>
<div class="required">
    <span class="header">Exercise 10.</span>
    Implement the algorithm to insert the &phi;-functions, as
    described by Algorithm 19.6 in the Tiger book.
</div>

<h3>Renaming the Variables</h3>
<div class="required">
    <span class="header">Exercise 11.</span>
    Implement the algorithm to rename the variables, as
    described by Algorithm 19.7 in the Tiger book.
</div>
<p>
    To this point, your Tiger compiler can convert all legal MiniJava
    programs to SSA forms. Do regression test on your Tiger compiler.
</p>

<hr/>
<h2>Part C: SSA-based Optimizations</h2>
<p>
    SSA makes optimizations much
    easier, as its single-assignment property makes it
    much easier to calculate the data flow information
    required to perform optimizations.
</p>

<p>
    In this part of the lab, you will implement several optimizations
    on SSA: dead code-elimination, constant propagation,
    conditional constant propagation, etc.
</p>

<h3>Dead-code Elimination</h3>
<p>
    In SSA, a statement <code>x = e</code> is dead,
    if the variable <code>x</code> is not used in any other
    statement (and <code>e</code> does not have side effects).
    As a result, this statement <code>x = e</code> can be safely
    removed.
</p>

<div class="required">
    <span class="header">Exercise 12.</span>
    Implement the algorithm to remove dead-code.
    Pay special
    attention to the pitfalls mentioned above not to remove
    live statements. Also note that removing one dead code may make
    other live code dead, so make sure that your dead-code elimination
    optimization is cascaded to eliminate ALL dead code.
</div>
<p>
    To test your Tiger compiler, you can run your Tiger compiler on
    the monster program from lab 1, which contains many dead code.
</p>

<h3>Constant Propagation</h3>
<p>
    In SSA, given a statement of the form <code>x = c</code> in which
    <code>c</code> is some constant, any use of variable <code>x</code>
    can be replaced by <code>c</code>.
</p>
<div class="required">
    <span class="header">Exercise 13.</span>
    Implement the constant propagation algorithm.
    Pay attention to the &phi;-functions which are also
    definitions.
    And think carefully of the basic data structure designs
    to make your algorithm efficient.
</div>

<h3>Copy Propagation</h3>
<p>
    In SSA, given a copy statement <code>x = y</code>, then
    any use of <code>x</code> can be replaced by <code>y</code>.
</p>

<div class="required">
    <span class="header">Exercise 14.</span>
    Implement the copy propagation algorithm.
</div>

<h3>Conditional Constant Propagation</h3>

<div class="required">
    <span class="header">Exercise 15.</span>
    Implement the conditional constant propagation algorithm, using
    the lattice-based insight.
</div>
<p>
    Do not forget to test Tiger compiler then finished all these
    optimizations.
</p>


<hr/>
<h3>Hand-in</h3>
<p>
    This completes the lab. Remember to hand in your solution to
    the online teaching system.
</p>


<br>
<br>
<br>
<br>


</body>
</html>
















