<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html">
    <title>Lab 3: Intermediate Representation</title>
    <link rel="stylesheet" href="../labs.css" type="text/css">
</head>

<body>

<h1>Lab 3: Intermediate Representation</h1>
<hr>

<h2>Overview</h2>
<p>
    In this lab, you will design and implement intermediate
    representations for your <code>Tiger</code> compiler, and lower
    down MiniJava programs by translating
    the abstract syntax trees to the intermediate representation
    you designed.
</p>
<p>
    This lab consists of three parts: first, in part A, you
    will design and implement a specific intermediate representation:
    a <a href="https://en.wikipedia.org/wiki/Control_flow_graph">control-flow graph</a>.
    Second, in part B, you will eliminate the object-oriented features
    in MiniJava by using a prefixing algorithm.
    Finally, in part C, you will implement a translator to lower
    down the abstract syntax tree to the control-flow graph.
</p>


<h3>Getting Started</h3>
<p>
    First check out the source we offered you for lab 3:
</p>
<pre>
    $ <kbd>git commit -am 'my solution to lab2'</kbd>
    $ <kbd>git checkout -b lab3 origin/lab3</kbd>
</pre>
<p>
    these commands will first commit your changes to the lab2
    branch of your local Git repository, and then create a
    local lab3 branch and check out the remote lab3 branch
    into the new local lab3 branch.
</p>
<p>
    Again, you will need to merge your code from lab2 into the
    new lab3 branch:
<pre>
    $ <kbd>git merge lab2</kbd>
</pre>
<p>
    Do not forget to resolve any conflicts before commiting to
    the local lab3 branch:
</p>

<pre>
    $ <kbd>git commit -am 'lab3 init'</kbd>
</pre>
<p>
    You should first import the new Lab5 code into
    your Eclipse editor, and make sure the code compiles. There
    are a bunch of new files that you
    should browse through:
</p>
<pre>
    cfg/*:    control-flow graph data structures and operations
</pre>

<h3>Hand-in Procedure</h3>
<p>
    When you finished this lab, zip you code and submit to the
    <a href="https://bb.ustc.edu.cn">online teaching system</a>.
</p>

<hr/>
<h1>Part A: Control-flow Graph</h1>
<p>
    A <a href="https://en.wikipedia.org/wiki/Control_flow_graph">
    control-flow graph</a>
    (CFG) is a graph-based program intermediate representation
    with basic blocks as nodes and control
    transfers between blocks as edges.
    A control-flow graph
    is a good intermediate representation as it makes every aspect
    of program control- and data-flow properties explicit thus
    easier to compute.
    As a result, in modern compilers, CFGs serve as not only
    carriers for compiler optimizations, but also backbones
    for more advanced intermediate representations such as
    static single-assignment forms (SSA).
</p>

<h3>Data Structures</h3>
<p>
    In this part of the lab, you will familiarize yourself
    with data structures defining the control-flow
    graph representation. In the rest of this lab, you will
    need to extend these data structures to support more features
    in the source language.
</p>

<div class="required">
    <span class="header">Exercise 1.</span>
    Read the code in <code>cfg/Cfg.java</code>, make sure you understand
    the Java code defining CFG data structures we offered you.
    To investigate the generated
    CFG, you can compile some test cases to gain some idea about
    its structure.
    For example,
    you can compile the test case <code>test/SumRec.java</code> to
    inspect the generated CFG:
    <pre>
    $ <kbd>java -cp ./bin Tiger ./test/SumRec.java -dump cfg</kbd></pre>
    It should be noted that, while you do not need to write
    code for this exercise, you will need to extend these
    data structures in the following to support all language
    features of MiniJava.
</div>

<p>
    It is often important to measure the sizes of
    the generated CFG, which represents the memory occupation.
    For example, after you have implemented
    a compiler optimization to optimize the target CFG by shrinking
    its size, you can evaluate the effectiveness of your
    optimization by comparing the sizes before and after the
    optimization.
</p>

<div class="required">
    <span class="header">Exercise 2.</span>
    Finish the <code>size()</code> methods in the file
    <code>cfg/Cfg.java</code>, to measure the size of the CFG
    in terms of the numbers of functions,
    basic blocks, and statements. The output should
    look like this:
    <pre>
        &lt;#functions, #blocks, #statements>
        ---------------------------------
        <"f1", 5,  300>
        <"g",  30, 400>
        ...
        ---------------------------------
        subtotal 140, 25000
    </pre>
    which specifies that the function <code>f1</code> has
    5 basic blocks and 300 statements, whereas the function
    <code>g</code> has 30 basic blocks and 400 statements, and
    so on.
    In a summary, there are 140 basic blocks in the target
    MiniJava program with 25,000 statements.
</div>

<h3>Graph Visualization</h3>
<p>
    It will be nice to
    <a href="https://en.wikipedia.org/wiki/Graph_visualization">
        visualize a control-flow graph</a>,
    making subsequent graph analysis easier.
    Nevertheless, to draw a figure prettily
    is a nontrivial task and may require too much programming
    effort.
    So your Tiger compiler will make use
    of the <a href="https://graphviz.org/">Graphviz</a>,
    a very popular software for graph visualization, to
    visualize a control-flow graph.
</p>

<div class="required">
    <span class="header">Exercise 3.</span>
    Download
    <a href="https://graphviz.org/Download.php">graphviz</a>
    and install it
    on your machine. Do not forget to add it to your PATH.
    To make sure you have installed graphviz correctly, you can
    run the following command on your prompt:
    <pre>
        $ <kbd>dot --help</kbd>
        Usage: dot [-Vv?] [-(GNE)name=val] [-(KTlso)&lt;val>] &lt;dot files&gt;
        (additional options for neato)    [-x] [-n&lt;v&gt;]
        (additional options for fdp)      [-L(gO)] [-L(nUCT)&lt;val&gt;]
        (additional options for config)  [-cv]
        ...</pre>
    Also, you can take a look at
    <a href="https://graphviz.org/Documentation.php">its manual</a>,
    if you are interested in.
</div>

<p>
    The Tiger compiler has rudimentary support for CFG
    visualization, that is, it can draw a graph for each
    function in a program.
</p>

<div class="required">
    <span class="header">Exercise 4.</span>
    Finish the code <code>dot()</code> in the file
    <code>cfg/Cfg.java</code>, to visualize a CFG for
    each function.
    When you finish, test your Tiger compiler using
    the <code>-visualize</code> option. For instance, to test
    the
    <code>test/SumRec.java</code> test case, you can compile it with:
    <pre>
        $ <kbd>java -cp ./bin Tiger ./test/SumRec.java -visualize cfg</kbd></pre>
    This command will draw two figures in jpeg format.
</div>

<p>
    Don't forget to test your Tiger compiler before
    continuing.
</p>


<hr/>
<h2>Part B: Class Elimination</h2>
<p>
    The class elimination pass eliminates classes and inheritance
    using a prefixing algorithm, and closes each method by introducing
    an explicit <code>this</code> parameter.
</p>

<div class="required">
    <span class="header">Exercise 5.</span>
    Read the code in the file <code>cfg/InheritTree.java</code>
    and the <code>prefixing()</code> algorithm in the file
    <code>cfg/Translate.java</code>, make sure you understand
    these algorithms.
    You do not need to write any code for this exercise.
</div>

<p>
    As a result, a MiniJava class will be translated into
    three components: a structure (like structs in C), a virtual
    function table holding a list of function pointers to
    all the constituting methods in the class, and a list of
    methods that have been lifted out the class.
</p>


<hr/>
<h2>Part C: CFG Generation</h2>
<p>
    The CFG generation phase generates a CFG representation
    from the abstract syntax tree. The generation uses a
    recursive-decedent algorithm.
</p>
<div class="required">
    <span class="header">Exercise 6.</span>
    Read the code in the file
    <code>cfg/Translate.java</code>, to finish the translation algorithm.
</div>
<p>
    Do not forget to test your Tiger compiler using
    the test cases in <code>test</code>.
    Fix any bugs before continuing.
</p>


<hr/>
<h2>Part D: CFG-based Optimizations</h2>
<p>
    <span style="color: red">This part in optional</span>.
</p>

<p>
    CFG makes program optimizations much
    feasible by calculating the control-flow and
    data-flow information, which are
    essential to perform optimizations.
    Generally
    speaking, a compiler optimization consists of two phases:
    <a href="https://en.wikipedia.org/wiki/Program_analysis">program
        analysis</a> and rewriting. The program analysis phase
    analyzes the target program being optimized to get useful
    static information to approximate the program's dynamic
    behavior. And program rewriting phase
    rewrites the program being optimized, using the static
    information calculated in the first phase.
</p>
<p>
    In this part of the lab, you will familiarize yourself
    with compiler optimizations by writing several classical program
    analysis (e.g., liveness analysis, reaching definitions, available
    expressions), and classical
    optimizations (e.g., constant propagation,
    copy propagation, dead code elimination).
</p>

<h3>Liveness Analysis</h3>
<p>
    You will first write
    <a href="https://en.wikipedia.org/wiki/Liveness_analysis">liveness analysis</a>
    which calculates, for each statement
    and each transfer in a basic block, the live-in and live-out variable sets.
</p>
<p>
    You will write your liveness analysis algorithm (in fact, most
    data-flow analysis algorithms)
    on a basic block granularity with the following general
    template:
</p>
<pre>
data_flow()
  calculate the <em>gen</em> and <em>kill</em> sets for each statement and transfer;
  calculate the <em>gen</em> and <em>kill</em> sets for each basic block;
  calculate the <em>in</em> and <em>out</em> sets for each basic block;   // fix-point
  calculate the <em>in</em> and <em>out</em> sets for each statement and transfer.
</pre>
<p>
    For specific data-flow you will write next, you will need to
    modify this algorithm template to finish your work, as
    different data-flow algorithms will be of minor differences.
    For instance, for the
    liveness analysis in this part, you should calculate
    <code>live_in</code> and <code>live_out</code> for the <code>in</code>
    and <code>out</code> separately; and the fix-point code should
    calculate the <code>in</code> and <code>out</code> sets for
    each basic block in a reverse topo-sort order.
    But for other data-flow analysis, these details may be different.
</p>
<div class="required">
    <span class="header">Exercise 7.</span>
    Finish the liveness analysis code by creating a new source file
    <code>cfg/Liveness.java</code> and implementing the
    aforementioned algorithm.
</div>

<h3>Dead-code Elimination</h3>
<p>
    An assignment statement <code>x = v</code> is dead,
    if the variable <code>x</code> does not live out this
    statement. Hence, this statement can be safely
    removed.
</p>
<div class="required">
    <span class="header">Exercise 8.</span>
    Finish the liveness analysis code by creating a new source file
    <code>cfg/Liveness.java</code> and implementing the
    aforementioned algorithm. You should pay special
    attention to the pitfalls discussed in the Tiger book by not removing
    live statements. Also note that removing one dead code may
    have cascading effects by making
    other code dead, so make sure that your dead-code elimination
    optimization can eliminate <em>all</em> dead code.
</div>

<h3>Reaching Definitions</h3>
<p>
    Intuitively, a reaching
    definition analyzes which definition can reach which use.
</p>
<div class="required">
    <span class="header">Exercise 9.</span>
    Implement the reaching definition analysis.
    This
    algorithm is similar to the liveness analysis algorithm, except for
    it performs the analysis in a forward manner.
</div>

<h3>Constant Propagation</h3>
<p>
    A constant propagation propagates a constant definition
    to it uses. For example, for any statement <code>s</code>
    of the form <code>x = y op z</code>, where the variable
    <code>y</code> is defined in
    by a statement t like <code>y = c</code> where <code>c</code>
    is a constant. And
    suppose the definition t is the unique definition that reaches
    the statement s. Then we can replace, in
    the statement s, the variable <code>y</code> by
    the constant <code>c</code>.
</p>
<div class="required">
    <span class="header">Exercise 10.</span>
    Finish the constant propagation code in the file
    <code>cfg.optimizations.ConstProp.java</code>. Note that to this point, the
    Tiger compiler will perform all these analysis and optimizations
    in a linear order, however, this is not the desired order
    for optimizations. So, you may want to modify the
    <code>cfg.optimizations.Main.java</code> code to use a
    fancy order.
</div>

<h3>Copy Propagation</h3>
<p>
    Copy propagation is like constant propagation.
    Suppose, for any statement <code>s</code> of the form <code>x = y</code>
    or <code>x = y op z</code>, where <code>y</code> is defined in
    some statement t like <code>y = m</code> with a variable <code>m</code>. And
    suppose the definition t is the unique definition that reaches
    the statement s. Then you can replace the variable <code>y</code>, in
    the statement s, with the variable <code>m</code> from the statement t.
</p>
<div class="required">
    <span class="header">Exercise 11.</span>
    Finish the constant propagation code in the file
    <code>cfg.optimizations.ConstProp.java</code>.
</div>

<h3>Available Expressions</h3>
<p>
    Consider the statement <code>x = y op z</code>, if the expression
    <code>y op z</code> has been computed before this statement, then
    the expression <code>y op z</code> can reuse the computed result.
    Hence, you can compute whether the expression <code>y op z</code>
    is available here.
</p>
<div class="required">
    <span class="header">Exercise 12.</span>
    Finish the available expression analysis in the file
    <code>cfg.optimizations.AvailExp.java</code>.
</div>

<h3>Common Sub-Expression Elimination (CSE)</h3>
<p>
    For the statement <code>x = y op z</code>, if the expression
    <code>y op z</code> is available. We can substitute the
    expression <code>y op z</code> with the most recent definition
    using <code>y op z</code>. You can read the Tiger book
    section 17.3 for this algorithm.
</p>
<div class="required">
    <span class="header">Exercise 13.</span>
    Implement constant propagation.
</div>

<h3>Safe Points and Precise GC</h3>
<p>
    Liveness analysis has many important applications in compilers
    besides optimizations. In this part
    of the lab, you will implement another important application
    of liveness analysis: precise garbage collection.
</p>
<p>
    In order to perform a much precise garbage collection, we can
    introduce the concept of <em>safe points</em>: positions
    which are safe to emit GC stack frames. Because the MiniJava
    language you
    are compiling is single-threaded, so the safe points are
    function invocations (including constructor invocations). The basic
    idea is to emit different GC stack frames before each function
    invocation, and each GC stack frame only contains the live
    references at that point (that is: the live in set of that
    function invocation). To better understand this, consider the
    code fragment above, you can generate two different GC stack
    frame for the two method invocations, like this:
</p>
<pre>
  A f (){
    A x, y;
    // generate the first frame (empty):  {}
    x = new A();
    // generate the second frame: {y}
    y = new A();
    return y;
  }
</pre>
<p>
    As you can see, the reference <code>x</code> will not appear
    in any GC frame at all.
</p>
<div class="required">
    <span class="header">Exercise 14.</span>
    Port your Gimple garbage collector to control-flow graph to do
    precise garbage collection. You should calculate the live
    in set for each method invocation and generate GC frame
    based on that.
</div>
<div class="required">
    <span class="header">Exercise 15.</span>
    In the above code, the variable <code>x</code> is never used. So
    can we do dead code elimination to remove the assignment statement
    to <code>x</code>?
</div>

<hr/>
<h2>Hand-in</h2>
<p>
    This completes the lab. Remember to hand in your solution to
    the online teaching system.
</p>


<br>
<br>

</body>
</html>




