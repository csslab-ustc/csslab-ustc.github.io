\documentclass[a4paper, 10pt]{article}
\usepackage{amsmath, amssymb, graphicx, styfiles/code, styfiles/bcprules}

%-------------- lengths (for A4 paper only)
\addtolength{\topmargin}{-54pt}
\setlength{\oddsidemargin}{0cm}  % no margin
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textwidth}{16.51cm}      % 6.5in
\setlength{\textheight}{24cm}    %
%-------------- lengths (for A4 paper only)

\renewcommand{\baselinestretch}{1.2}


\newcommand{\ang}[1]{\text{#1}}
\newcommand{\dotdoteq}{::=}
\newcommand{\imply}{\supset}
\newcommand{\hei}[1]{{\CJKfamily{hei}#1}}
\newcommand{\kai}[1]{{\CJKfamily{kai}#1}}
\newcommand{\largeto}{\Downarrow}
\newcommand{\mynoindent}{\noindent}
\newcommand{\mytt}[1]{{\tt #1}}
\newcommand{\sep}{\ |\ }
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\smallto}{\longrightarrow}
\newcommand{\tpr}[3]{\vdash{#1}\curvearrowright{#2}\rhd{#3}}


\begin{document}

\begin{center}
\center{\Large {\bf School of Software Engineering, USTC (Suzhou)}}\\
\center{\Large {\bf Exam Paper for Academic Year 2020-2021-2}}\\
\center{\Large {\bf Open or Close: Open}}\\
\vskip.5cm
\begin{tabular}{l l}
  %\hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  Course: \underline{Information Security$\kern1.3cm$}\kern2cm &
  Time: \underline{July 21, 2021$\kern2.6cm$}\kern2cm \\
  Student Name: \underline{$\kern3.35cm$} & Student No.\underline{$\kern3.88cm$}\\
  Class: \underline{$\kern4.7cm$} & Score:\underline{$\kern4.8cm$}\\
  %\hline
\end{tabular}
\end{center}

\vskip.5cm
\section*{Part I: Integer Overflow}
\noindent 1. (10 points) This problem is based on the paper
\textit{Basic Integer Overflows} by blexim. Read the following
code:
\begin{code}
int myfunction(int *array, int len)\{
        int *myarray, i;

        myarray = malloc(len * sizeof(int));
        if(myarray == NULL)\{
            return -1;
        \}

        for(i = 0; i < len; i++)\{
            myarray[i] = array[i];
        \}

        return myarray;
\}
\end{code}
Now, please answer this question: is this code safe? Explain
you conclusion briefly.

\newpage


\section*{Part II: Format String Attack}
\noindent 2. (10 points) This problem is based on the paper
\textit{Exploiting Format String Vulnerabilities} by
scut/teso. On page 15 of this paper, there is some
code like this:
\begin{code}
/* 1 */ printf ("%16u%n", 7350, (int *) &foo[0]);
/* 2 */ printf ("%32u%n", 7350, (int *) &foo[1]);
/* 3 */ printf ("%64u%n", 7350, (int *) &foo[2]);
/* 4 */ printf ("%128u%n", 7350, (int *) &foo[3]);
\end{code}
Now please answer these questions:
\begin{description}
  \item[(a)] what does this code sequence do?
  \item[(b)] what's the security vulnerability of this code?
\end{description}

\newpage



\section*{Part III: Heap Overflow}
\noindent 3. (10 points) This problem is based on the paper
{\it w00w00 on Heap Overflows}. On page 12 of this paper is
this code. Explain briefly why this code is unsafe and how
to attack it.
\begin{code}
\#include <stdio.h>
\#include <stdlib.h>
\#include <unistd.h>
\#include <string.h>
\#include <setjmp.h>
\#define ERROR -1
\#define BUFSIZE 16

static char buf[BUFSIZE];
jmp\_buf jmpbuf;

u\_long getesp()\{
  \_\_asm\_\_("movl \%esp, \%eax"); /* the return value goes in \%eax */
\}

int main(int argc, char **argv)\{
  if (argc <= 1)\{
    fprintf(stderr, "Usage: \%s <string1> <string2>$\backslash$n");
    exit(ERROR);
  \}
  printf("[vulprog] argv[2] = \%p$\backslash$n", argv[2]);
  printf("[vulprog] sp = 0x\%lx$\backslash$n$\backslash$n", getesp());
  if (setjmp(jmpbuf))\{ /* if > 0, we got here from longjmp() */
    fprintf(stderr, "error: exploit didn't work$\backslash$n");
    exit(ERROR);
  \}
  printf("before:$\backslash$n");
  printf("bx = 0x\%lx, si = 0x\%lx, di = 0x\%lx$\backslash$n",
  jmpbuf->\_\_bx, jmpbuf->\_\_si, jmpbuf->\_\_di);
  printf("bp = \%p, sp = \%p, pc = \%p$\backslash$n$\backslash$n",
  jmpbuf->\_\_bp, jmpbuf->\_\_sp, jmpbuf->\_\_pc);
  strncpy(buf, argv[1], strlen(argv[1])); /* actual copy here */
  printf("after:$\backslash$n");
  printf("bx = 0x\%lx, si = 0x\%lx, di = 0x\%lx$\backslash$n",
  jmpbuf->\_\_bx, jmpbuf->\_\_si, jmpbuf->\_\_di);
  printf("bp = \%p, sp = \%p, pc = \%p$\backslash$n$\backslash$n",
  jmpbuf->\_\_bp, jmpbuf->\_\_sp, jmpbuf->\_\_pc);
  longjmp(jmpbuf, 1);
  return 0;
\}
\end{code}

\newpage

\section*{Part IV: Race condition}
\noindent 4. (10 points) Read the following code and
explain briefly why this code may be unsafe.
\begin{code}
\#define DELAY 10000

int main()
\{
    char * fn = "/tmp/XYZ";
    char buffer[60];
    FILE *fp;
    long int  i;

    /* get user input */
    scanf("%50s", buffer );

    if(!access(fn, W\_OK))\{
      /* simulating delay */
      for (i=0; i < DELAY; i++)\{
        int a = i^2;
      \}

      fp = fopen(fn, "a+");
      fwrite("\\n", sizeof(char), 1, fp);
      fwrite(buffer, sizeof(char), strlen(buffer), fp);
      fclose(fp);
    \}
    else printf("No permission \\n");
\}
\end{code}

\newpage


\section*{Part V: Anti-Disassembly}
\noindent 5. (10 points) Read the following code, why malware writers
can use this code to make disassembly harder?
\begin{code}
    .data
x:
    .int 0

    .text
main:
    ...  // some instructions omitted
    leal    x, \%eax          // load the address of x into \%eax
    cmpl    \$0x1000, \%eax   // to compare the value again 0x1000
    jl      .L                // jump if less
    .byte 0xe8
.L
    ...  // some instructions omitted
\end{code}

\newpage







\section*{Part VI: Anti-Debugging}
\noindent 6. (10 points) One hacker Alice wrote a virus and
she intended to introduce some techniques to perform
anti-debugging. So she added the following three lines of code
to her virus:
\begin{code}
int main ()
\{
    int r = ptrace(PTRACE\_TRACEME, 0, 0, 0);   // newly added code
    if (r<0)                                   // newly added code
      exit (0);                                // newly added code
$ $\

    // remaining code for her great virus
\}
\end{code}
Question: can Alice achieve her goal of anti-debugging? Why or why not?

\newpage





\section*{Part VII: Anti-Virtual Machine}
\noindent 7. (10 points) Suppose one day in the future, Intel suddenly announces
its next generation chip, but one strange feature of this chip is that one of
its legacy instruction will not be supported any more (for instance, this
unsupported instruction is {\tt inc \%eax}). But emulator vendors will
take some time to update their emulators to resolve this. Then is there
some opportunity for malware writers to take advantage of this? If so, how?
If not, why?

\newpage



\section*{Part VIII: Trojan Horse}
\noindent 8. (10 points) In class, we discussed a special kind of trojan
horse---the Thompson horse, which is planted into the compiler's binary. Then
why Thompson's workmates failed to disassembly the compiler's binary and
find out Thompson's trojan horse? Now suppose we would like to plant the
same kind of trojan horse into the current version of GCC, then how can
we modify GCC's source code?


\end{document}
